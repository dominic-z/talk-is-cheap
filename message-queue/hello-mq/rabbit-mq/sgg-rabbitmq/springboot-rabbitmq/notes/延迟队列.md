# 延迟队列

> 如果设置了队列的 TTL 属性，那么一旦消息过期，就会被队列丢弃(如果配置了死信队列被丢到死信队列中)，而
> 第二种方式，消息即使过期，也不一定会被马上丢弃，因为消息是否过期是在即将投递到消费者之前判定的，
> 如果当前队列有严重的消息积压情况，则已过期的消息也许还能存活较长时间；
> 
上述的含义是，带ttl的消息在过期之后并不会被立刻干掉，因为判断一个带ttl的信息是否被干掉的时机是这条消息准备好被消费的时候；

# 延迟队列ttl优化
这个时候就相当于对消息粒度设置ttl时间，但从下列实验可以看到，`你好2`原本应该在2s后过期，但是由于他排在`你好1`后面，而`你好1`在20s后才会进入死信队列，所以说检测`你好2`的时间，是在是这条消息准备好被消费的时候；
> 当前时间：Tue Jan 18 20:19:35 CST 2022,发送一条时长20000毫秒 TTL 信息给队列 C:你好1 
> 
> 当前时间：Tue Jan 18 20:19:38 CST 2022,发送一条时长2000毫秒 TTL 信息给队列 C:你好2
> 
> 当前时间：Tue Jan 18 20:19:55 CST 2022,收到死信队列信息你好1
> 
> 当前时间：Tue Jan 18 20:19:55 CST 2022,收到死信队列信息你好2

# Rabbitmq 插件实现延迟队列

之前都是通过生产者队列+死信队列 = 延迟队列 ，来获得一个延迟队列的，而这种交换机，自动帮我们完成了全套的，不需要配置生产者队列与消费者队列了，
> 在我们自定义的交换机中，这是一种新的交换类型，该类型消息支持延迟投递机制消息传递后并不会立即投递到目标队列中，而是存储在 mnesia(一个分布式数据系统)表中，当达到投递时间时，才投递到目标队列中。

教程里使用的是3.8.0版本的rabbitmq_delayed_message_exchange

同样通过先发ttl20s的消息再发ttl2s的消息来验证有效，如下，发现有效

> 当 前 时 间 ： Tue Jan 18 21:00:52 CST 2022, 发 送 一 条 延 迟 20000 毫秒的信息给队列 delayed.queue:hello1
> 
> 当 前 时 间 ： Tue Jan 18 21:00:55 CST 2022, 发 送 一 条 延 迟 2000 毫秒的信息给队列 delayed.queue:hello2
> 
> 前时间：Tue Jan 18 21:00:57 CST 2022，从delayed.queue收到延时队列的消息：hello2
